# Puppet Language

A **Declarative** Domain Specific Language (DSL)

It defines **STATES** (Not procedures)

Puppet code is written in **manifests** (files with **.pp** extension)

In the code we declare **resources** that affect elements of the system (files, packages, services ...)

Resources are grouped in **classes** which may expose parameters that affect their behavior.

Classes and configuration files are organized in **modules**.

Consult the **[official glossary](https://docs.puppetlabs.com/references/glossary.html)** to give the correct meaning to Puppet terms

# Nodes classification

When clients connect, the Puppet Master generate a **catalog** with the list of of the resources to apply locally.

The Puppet Master has to qualify nodes and define for each of them:

  - The **classes** to include
  - The **parameters** to pass
  - The Puppet **environment** to use

The **catalog** is generated by the Master according to the logic of our Puppet code and data.

In our code we can define our **variables** and user other ones that may come from different sources:

  - **facts** generated directly from client
  - **parameters** from node's classification
  - Puppet **internal** variables



# Resource Types (Types)

Resource Types are single **units of configuration** composed by:

A **type** (package, service, file, user, mount, exec ...)

A **title** (how is called and referred)

One or more **arguments**

    type { 'title':
      argument  => value,
      other_arg => value,
    }

Example for a **file** resource type:

    file { 'motd':
      path    => '/etc/motd',
      content => 'Tomorrow is another day',
    }


# Resource Types reference

Find online the complete [Type Reference](http://docs.puppetlabs.com/references/latest/type.html) for the latest o ealier versions.

From your shell, or use directly the command line:

    puppet describe file

For the full list of available descriptions try:

    puppet describe --list


Give a glance to Puppet code for the list of **native** resource types:

    ls $(facter rubysitedir)/puppet/type


# Simple samples of resources

Installation of OpenSSH package

    package { 'openssh':
      ensure => present,
    }

Creation of /etc/motd file

    file { 'motd':
      path => '/etc/motd',
    }

Start of httpd service

    service { 'httpd':
      ensure => running,
      enable => true,
    }


# More complex samples of resources

Management of nginx service with parameters defined in module's variables

    service { 'nginx':
      ensure     => $::nginx::manage_service_ensure,
      name       => $::nginx::service_name,
      enable     => $::nginx::manage_service_enable,
    }

Creation of nginx.conf with content retrieved from different sources (first found is served)

    file { 'nginx.conf':
      ensure  => present,
      path    => '/etc/nginx/nginx.conf',
      source  => [
          "puppet:///modules/site/nginx.conf--${::fqdn}",
          "puppet:///modules/site/nginx.conf-${::settings::role}",
          "puppet:///modules/site/nginx.conf" ],
    }


# Resource Abstraction Layer

Resources are abstracted from the underlying OS

Resource Types have different providers for different OS

Package type is known for the great number of providers

     ls $(facter rubysitedir)/puppet/provider/package

Use **puppet resource** to interrogate the RAL:

    puppet resource user

    puppet resource user root

    puppet resource package

    puppet resource service

Or to directly modify resources:

    puppet resource service httpd ensure=running enable=true


# Classes

Classes are **containers** of different resources. Since Puppet 2.6 they can have parameters

Example of a class **definition**:

    class mysql (
      root_password => 'default_value',
      port          => '3306',
    }
      package { 'mysql-server':
        ensure => present,
      }
      service { 'mysql':
        ensure    => running,
      }
      [...]
    }

Usage (declaration) of "old style" classes (without parameters):
Even if a class is a singleton, you can include it multiple times: it's applied only once.

    include mysql

Usage (declaration) of a parametrized classes
You can declare a parametrized class only once for a node

    class { 'mysql':
      root_password => 'my_value',
      port          => '3307',
    }


# Defines

Also called: **Defined resource types** or **defined types**

Similar to parametrized classes but can be used multiple times, with different parameters

**Definition** example:

    define apache::virtualhost (
      $ensure   = present,
      $template = 'apache/virtualhost.conf.erb' ,
      [...] ) {

      file { "ApacheVirtualHost_${name}":
        ensure  => $ensure,
        content => template("${template}"),
      }
    }

Usage example (**declaration**):

    apache::virtualhost { 'www.example42.com':
      template => 'site/apache/www.example42.com-erb'
    }



# Variables

You need them to provide different configurations for different kind of servers

Can be provided by client nodes as **facts**

**Facter** runs on clients and collects **facts** that the server can use as variables

    al$ facter

    architecture => x86_64
    fqdn => Macante.example42.com
    hostname => Macante
    interfaces => lo0,eth0
    ipaddress => 10.42.42.98
    ipaddress_eth0 => 10.42.42.98
    kernel => Linux
    macaddress => 20:c9:d0:44:61:57
    macaddress_eth0 => 20:c9:d0:44:61:57
    memorytotal => 16.00 GB
    netmask => 255.255.255.0
    operatingsystem => Centos
    operatingsystemrelease => 6.3
    osfamily => RedHat
    virtual => physical

Or can be **defined by users**.


# User Variables

You can define custom variables in different ways:

#### In Puppet **manifests**:

        $role = 'mail'

        $package = $::operatingsystem ? {
          /(?i:Ubuntu|Debian|Mint)/ => 'apache2',
          default                   => 'httpd',
        }

#### In an **External Node Classifier** (ENC)

Commonly used ENC are Puppet DashBoard, the Foreman, Puppet Enterprise.

#### In an **Hiera** backend

        $syslog_server = hiera(syslog_server)


# Nodes - Default classification

A node is identified by the PuppetMaster by its **certname**, which defaults to the node's **fqdn**


## In the site manifest

Using Puppet language ( Starting from ```/etc/puppet/manifests/site.pp``` ) you can define nodes with a syntax like:

    node 'web01' {
      include apache
    }

You can also define a list of matching names:

    node 'web01' , 'web02' , 'web03' {
      include apache
    }

or use a regular expression:

    node /^www\d+$/ {
      include apache
    }

A node can inherit another node and include all the classes and variables defined for it, this feature is now deprecated and is not supported anymore on Puppet 4.


# Nodes - Alternative approaches

Classes can be assigned to nodes in alternative ways:

## On an External Node Classifier (ENC)
Puppet can query an external source to retrieve the classes and the variables to assign to a node. This source is called External Node Classifier and can be anything that when interrogated via a script with the clients' certname returns a yaml file with the list of classes and parameters.

Common ENC are Puppet DashBoard, Foreman and Puppet Enterprise (where the functionality of ENC is enabled by default).

To enable the usage of an ENC set these parameters in puppet.conf

    external_nodes = /etc/puppet/node.rb # Script that queries the ENC
    node_terminus = exec                 # Enable the usage of the script

## With hiera_include

Hiera provides a **hiera_include** function that allows the inclusion of classes as defined on Hiera. This is an emerging approach that is particularly useful when there's massive usage of Hiera as backend for Puppet data.

In ```/etc/puppet/manifests/site.pp``` just place:

    hiera_include('classes')

and place, as an array, the classes to include in you Hiera data source under the key 'classes'.

# The Catalog

The **catalog** is the complete list of resources, and their relationships, that the Puppet Master compiles for the client.

It's the result of all the puppet code and logic that we define for a given node in our manifests and is applied on the client after it has been compiled and received from the master.

The client uses the RAL (Resource Abstraction Layer) to execute the actual system's commands that convert abstract resources like

    package { 'openssh': }

to their actual fullfillment on the system (```apt-get install openssh``` , ```yum install openssh``` ...).

The catalog is saved by the client in ```/var/lib/puppet/client_data/catalog/$certname.json```
